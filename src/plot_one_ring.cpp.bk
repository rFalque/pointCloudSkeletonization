#include <igl/unproject_onto_mesh.h>
#include <igl/opengl/glfw/Viewer.h>
#include <iostream>

#include <igl/readPLY.h>

#include "utils/options.hpp"
#include "skeleton_toolbox/point_ring.hpp"
#include "mesh_tools/nanoflannWrapper.hpp"

int main(int argc, char *argv[])
{
  // Create the peak height field
  Eigen::MatrixXi F;
  Eigen::MatrixXd V;

    options opts;
    opts.loadYAML("../config.yaml");

    igl::readPLY(opts.path_input_file,V, F);

    int k_for_knn = 20;

    // get the nearest neighbours
    nanoflann_wrapper knn_search(V);

    // get the one ring
    std::vector< OneRing > one_ring_list;
    for (int i=0; i<V.rows(); i++) {
        // (1) search for k closest points and (2) remove the point itself
        std::vector < int > neighbours_id;
        neighbours_id = knn_search.return_k_closest_points(V.row(i), k_for_knn+1);
        neighbours_id.erase(neighbours_id.begin());
        
        // look for the one_ring neighbors
        OneRing one_ring(i, neighbours_id, V);
        one_ring_list.push_back(one_ring);
    }


    // Initialize white
    Eigen::MatrixXd C = Eigen::MatrixXd::Constant(V.rows(),3,1);
    igl::opengl::glfw::Viewer viewer;
    bool down_on_mesh = false;
    const auto update = [&]()->bool
    {
        int fid;
        Eigen::Vector3f bc;
        // Cast a ray in the view direction starting from the mouse position
        double x = viewer.current_mouse_x;
        double y = viewer.core().viewport(3) - viewer.current_mouse_y;
        if(igl::unproject_onto_mesh(Eigen::Vector2f(x,y), viewer.core().view,
        viewer.core().proj, viewer.core().viewport, V, F, fid, bc))
        {
        // 3d position of hit
        const Eigen::RowVector3d m3 =
            V.row(F(fid,0))*bc(0) + V.row(F(fid,1))*bc(1) + V.row(F(fid,2))*bc(2);
        int cid = 0;
        Eigen::Vector3d(
            (V.row(F(fid,0))-m3).squaredNorm(),
            (V.row(F(fid,1))-m3).squaredNorm(),
            (V.row(F(fid,2))-m3).squaredNorm()).minCoeff(&cid);
        const int vid = F(fid,cid);

        Eigen::MatrixXd vertices_color = Eigen::MatrixXd::Constant(one_ring_list.size(), 3, 0.9);
        std::vector< int > one_ring = one_ring_list[vid].get_one_ring();

        for (int i = 0; i<one_ring.size(); i++) {
            vertices_color.row(one_ring.at(i)) << 1, 0.1, 0.1;
        }

        viewer.data().set_colors(vertices_color);
        return true;
        }
        return false;
    };
  viewer.callback_mouse_down =
    [&](igl::opengl::glfw::Viewer& viewer, int, int)->bool
  {
    if(update())
    {
      down_on_mesh = true;
      return true;
    }
    return false;
  };
  viewer.callback_mouse_move =
    [&](igl::opengl::glfw::Viewer& viewer, int, int)->bool
    {
      if(down_on_mesh)
      {
        update();
        return true;
      }
      return false;
    };
  viewer.callback_mouse_up =
    [&down_on_mesh](igl::opengl::glfw::Viewer& viewer, int, int)->bool
  {
    down_on_mesh = false;
    return false;
  };
  std::cout<<R"(Usage:
  [click]  Click on shape to pick new geodesic distance source
  ,/.      Decrease/increase t by factor of 10.0
  D,d      Toggle using intrinsic Delaunay discrete differential operators
)";

  viewer.callback_key_pressed =
    [&](igl::opengl::glfw::Viewer& /*viewer*/, unsigned int key, int mod)->bool
  {
    switch(key)
    {
    default:
      return false;
    case 'D':
    case 'd':
      break;
    case '.':
    case ',':
      break;
    }
    return true;
  };

  // Show mesh
  viewer.data().set_mesh(V, F);
  viewer.data().set_colors(C);
  viewer.data().show_lines = false;
      viewer.launch();

}