/*
*   farthest_sampling_by_sphere
*   by R. Falque
*   27/06/2019
*/

#ifndef FARTHEST_SAMPLING_BY_SPHERE_HPP
#define FARTHEST_SAMPLING_BY_SPHERE_HPP

#include <Eigen/Core>
#include <limits> 
#include <iostream>
#include "../mesh_tools/nanoflannWrapper.hpp"


int argMax(const Eigen::VectorXd & data)
{
    int argmax = 0;
    int max_dim = std::max(data.rows(), data.cols());
    for (int i=0; i<max_dim; i++)
        if (data(argmax) < data(i))
            argmax = i;
    return argmax;
}


inline bool farthest_sampling_by_sphere(Eigen::MatrixXd & in_cloud, double sample_radius, Eigen::MatrixXd & nodes){


    nanoflann_wrapper knn_search(in_cloud);
    std::vector<int> node_list;
    //Eigen::MatrixXd spls; // now 0*3
    Eigen::VectorXd corresp = Eigen::VectorXd::Zero(in_cloud.rows());
    Eigen::VectorXd mindst = Eigen::VectorXd::Constant(in_cloud.rows(), -1); // used as NaN


    for (int i=0; i<in_cloud.rows(); i++) {

        if (corresp(i) == 0) {
        
            mindst(i) = std::numeric_limits<double>::infinity();

int maxId2 = argMax(mindst);
std::cout << "maxId: " << maxId2 << std::endl;
std::cout << "maxId value: " << mindst(maxId2) << std::endl;
std::cout << "initial test for while loop: (corresp.array()==0).any()" << (corresp.array()==0).any() << std::endl;





//not np.all(corresp != 0.0)

std::cout << "*** enter while loop ******\n\n";
            while ( (corresp.array()==0).any() ) {
std::cout << "*** begin of while loop ***\n";

                int maxId = argMax(mindst);

std::cout << "maxId: " << maxId << std::endl;
std::cout << "maxId value: " << mindst(maxId) << std::endl;

                if ( mindst(maxId)==0 )
                    break;

                std::vector<int> neighbours_id;
                std::vector<double> neighbours_distances;
                knn_search.radius_search(in_cloud.row(maxId), sample_radius, neighbours_id, neighbours_distances);

std::cout << "result of the knn search : ";
for (int i=0; i<neighbours_distances.size(); i++)
{
    std::cout << neighbours_distances[i] << " ";
}
std::cout <<std::endl;

                bool all_corresp_marked = corresp(neighbours_id[0])!=0;
                for (int j=0; j<neighbours_id.size(); j++)
                    all_corresp_marked = all_corresp_marked & corresp(neighbours_id[j])!=0;
                
std::cout << "all_corresp_marked: " << all_corresp_marked << std::endl;

                if (all_corresp_marked) {
                //if (!(corresp.array()==0).any()) {
                    mindst(maxId) = 0;
                    break;
                }

std::cout << "Assign all closest point to the distance from the knn search: " << std::endl;


                node_list.push_back(maxId);
                for (int j=0; j<neighbours_id.size(); j++) {
std::cout << "mindst( neighbours_id["<< j <<"] ) = "<< mindst( neighbours_id[j] ) <<std::endl;   
std::cout << "neighbours_distances["<< j <<"] = " << neighbours_distances[j] <<std::endl;
std::cout << "neighbours_distances["<< j <<"] = " << mindst(neighbours_id[j]) <<std::endl;

                    if ( mindst( neighbours_id[j] ) > neighbours_distances[j] || mindst(neighbours_id[j])==-1 )  {
std::cout << "assign the neighbours_id["<< j <<"] to the value: " << neighbours_distances[j] <<std::endl;
                        mindst( neighbours_id[j] ) = neighbours_distances[j];
                        corresp(neighbours_id[j]) = node_list.size();
                    }
                }



std::cout << "*** end of while loop *****\n\n" << std::endl;
//std::cin.get();

            }
        }

    std::cin.get();
        
    }

    std::cout << "nodes : ";
    for (int i=0; i<node_list.size(); i++)
    {
        std::cout << node_list[i] << " ";
    }
    std::cout <<std::endl;

    nodes.resize(node_list.size(), 3);
    for (int i=0; i<node_list.size(); i++)
    {
        nodes(i,0) = in_cloud(node_list[i],0);
        nodes(i,1) = in_cloud(node_list[i],1);
        nodes(i,2) = in_cloud(node_list[i],2);
    }

    return true;
};

#endif
